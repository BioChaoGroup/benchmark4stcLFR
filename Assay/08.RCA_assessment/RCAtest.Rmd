---
title: "RCA test"
author: "Chao"
date: "4/24/2019"
output: 
  html_notebook:
    code_fold: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reshape2)
library(ggplot2)
library(plyr)
library(dplyr)
library(RColorBrewer)
```

# Initiation
First to download the assembly sequence from NCBI, info organized in excel `Experiments/20190307stLFR_RCA测试样品.xlsx`.  
Download location : `REF/fungal7mix/`.

```{bash, eval=FALSE}
cd REF/fungal7mix/
#...
awk -F '|' 'NR==FNR{a[$2]=$1}NR!=FNR{tag=substr($4,1,4);print a[tag]"\t"$4"\t"$0}' ID.map MIX7.tmp |sed 's/>//' > MIX7.faID

sed -i 's/^>gi|\([0-9]*\)|\([a-z]*\)|\([^|]*\)|/>\3\tgi|\1|\2|\3|/' MIX7.fa

awk 'NR==FNR{a[$2]=$1}NR!=FNR{sub(">","",$0);tag=substr($0,1,4);print a[tag]"\t"$1"\t"$0}' ID.map MIX7.tmp > MIX7.faID

```


**Validate profile** was generated by ITS amplicon pipeline by xiaohuan.  
- Location : `ValidateInfo/ALS土壤ITS_OTU.xlsx`

Then prepare `RCA1.rawseq.lst` and link output dir.  
> Note: Make sure the adapter sequence are assigned correctly.  

Sample tag:  
1. ALS: Real soil collection, ITS + RCA  
2. FM:  7 fungal mock mixture, ITS + RCA

```{bash,eval=FALSE}
#DB
bwa index $Repo/Sourc e/REF/fungal7mix/MIX7.fa -p $Repo/Source/REF/fungal7mix/MIX7.bwa
makeblastdb -in  $Repo/Source/REF/fungal7mix/MIX7.fa -input_type fasta -dbtype nucl -title Os_protein -parse_seqids -out $Repo/Source/REF/fungal7mix/MIX7.fa
#ITSx
mkdir $Repo/Source/REF/fungal7mix/MIX7_ITSx
ITSx -i $Repo/Source/REF/fungal7mix/MIX7.fa -o $Repo/Source/REF/fungal7mix/MIX7_ITSx/fungal7mix/MIX7_ITSx -t F --cpu 60
#mkln ../../Results/RCAs/RCA194
metabbq init -i RCA1.rawseq.lst -o ./ -c ../07.test_1mAsm/config.yaml -V
#modified config.yaml
metabbq smk -j -np {RCA194FM,RCA194ALS}/clean/BB.stat
```


Since a whole lane data are oversampled and of heavy computation, let me just pick 10% of them for following analysis.
```{bash, eval=FALSE}
#split
metabbq randomlyPick.pl -n 10 -m 3 -s 194 -t 4 -i RCA194FM/clean/fastp.sort.1.fq -o RCA194FM/clean/ds.sort.1 &
metabbq randomlyPick.pl -n 10 -m 3 -s 194 -t 4 -i RCA194FM/clean/fastp.sort.2.fq -o RCA194FM/clean/ds.sort.2 &
metabbq randomlyPick.pl -n 10 -m 3 -s 194 -t 4 -i RCA194ALS/clean/fastp.sort.1.fq -o RCA194ALS/clean/ds.sort.1 &
metabbq randomlyPick.pl -n 10 -m 3 -s 194 -t 4 -i RCA194ALS/clean/fastp.sort.2.fq -o RCA194ALS/clean/ds.sort.2 -v
#link
for i in {FM,ALS};do 
  mkdir -p RCA194$i\_00/clean
  ln -s ../../RCA194$i/clean/ds.sort.1_00.fq RCA194$i\_00/clean/fastp.sort.1.fq
  ln -s ../../RCA194$i/clean/ds.sort.2_00.fq RCA194$i\_00/clean/fastp.sort.2.fq
done

tag="00d10" # set a tag for 1st test
for i in {FM,ALS};do 
  mkdir -p RCA194$i\_00/$tag/{mash,Assemble_BI,Assemble_mashBC}
  rm RCA194$i\_00/{mash,Assemble_BI,Assemble_mashBC}
  for j in {mash,Assemble_BI,Assemble_mashBC};do
    ln -s $tag/$j RCA194$i\_00/$j
  done
done
```

****
```{r}

```

**remove adapters and primers**
```{bash,eval=FALSE}
for i in {FM,ALS};do 
  mv RCA194$i\_00/clean/fastp.sort.1.fq RCA194$i\_00/clean/fastp.Ad.sort.1.fq
  mv RCA194$i\_00/clean/fastp.sort.2.fq RCA194$i\_00/clean/fastp.Ad.sort.2.fq
done

metabbq delAd.pl ./primers.lst RCA194FM_00/clean/{fastp.Ad.sort.1.fq,fastp.Ad.sort.2.fq,fastp.sort.1.fq,fastp.sort.2.fq} &
metabbq delAd.pl ./primers.lst RCA194ALS_00/clean/{fastp.Ad.sort.1.fq,fastp.Ad.sort.2.fq,fastp.sort.1.fq,fastp.sort.2.fq}

```

**RUN!**
```{bash}
metabbq smk -j -np RCA194{FM,ALS}_00/batch.assemble.BI.sh
metabbq smk -j -np RCA194ALS_00/summary.BC.megahit.contig.fasta

#metabbq smk -j -np RCA194ALS/summary.BI.megahit.contig.fasta
metabbq smk -j -np RCA194ALS_00/summary.BI.idba.contig.fasta

```


```{r load0}
RESDIR <- "../../Results/RCAs"
BC4.bb.stat <- read.table("../../Results/APR842_00_00/clean/BB.stat",
                          col.names = c("count","num","cumsum"))
RCA0.bb.stat <- read.table("../../Results/RCA14_00/clean/BB.stat",
                           col.names = c("count","num","cumsum"))
FM.bb.stat <- read.table("../../Results/RCAs/RCA194FM/clean/BB.stat",
                         col.names = c("count","num","cumsum"))
ALS.bb.stat <- read.table("../../Results/RCAs/RCA194ALS/clean/BB.stat",
                         col.names = c("count","num","cumsum"))

#following subsets are with primers removed
FM00.bb.stat <- read.table("../../Results/RCAs/RCA194FM_00/clean/BB.stat",
                         col.names = c("count","num","cumsum"))
ALS00.bb.stat <- read.table("../../Results/RCAs/RCA194ALS_00/clean/BB.stat",
                         col.names = c("count","num","cumsum"))
```

#QC performance

```{r pressure, echo=FALSE}
bb.stat <- rbind(
  cbind(group="BC4",BC4.bb.stat),
  cbind(group="RCA0",RCA0.bb.stat),
  cbind(group="RCA1FM",FM.bb.stat),
  cbind(group="RCA1ALS",ALS.bb.stat),
  cbind(group="RCA1FM00",FM00.bb.stat),
  cbind(group="RCA1ALS00",ALS00.bb.stat)
)
bb.stat <- ddply(bb.stat,c("group"),transform,pCount=count/sum(count))
ggplot(bb.stat,aes(x=num,y=pCount,color=group)) + geom_line(alpha=.5) + geom_point(alpha=.3,size=.5) +
  scale_y_log10() + scale_x_log10() + xlab("#Reads/Bead") + ylab("proportion") + annotation_logticks()
```

```{r}
FM.bb.stat$sum <- sum(FM.bb.stat$count) + 926201436/4
ALS.bb.stat$sum <- sum(ALS.bb.stat$count) + 943768156/4
RCA1.bb.stat <- rbind(
  cbind(group="RCA1FM",FM.bb.stat),
  cbind(group="RCA1ALS",ALS.bb.stat)
)
RCA1.bb.stat$pCount <- RCA1.bb.stat$count/RCA1.bb.stat$sum

ggplot(RCA1.bb.stat,aes(x=num,y=pCount,color=group)) + geom_line(alpha=.5) + geom_point(alpha=.3,size=.5) +
  scale_y_log10() + scale_x_log10() + xlab("#Reads/Bead") + ylab("proportion")
ggplot(RCA1.bb.stat,aes(x=num,y=count,color=group)) + geom_line(alpha=.5) + geom_point(alpha=.3,size=.5) +
  scale_y_log10() + scale_x_log10() + annotation_logticks()
ggplot(FM.bb.stat,aes(x=num,y=cumsum)) + geom_line(alpha=.5) + geom_point(alpha=.3,size=.5) +
  scale_y_log10() + scale_x_log10() + annotation_logticks()
```

```{r}
test.dat <- RCA1.bb.stat%>%filter(num>=10&num<=100)
ddply(test.dat,"group",summarise,count=sum(count))
ggplot(RCA1.bb.stat%>%filter(num>=2&num<=20),aes(x=num,y=count,color=group)) + 
  geom_line(alpha=.5) + geom_point(alpha=.3,size=.5) + annotation_logticks(side="left") + 
  scale_y_log10() + scale_x_reverse() + xlab("#Reads/Bead") + ylab("proportion")

```


## bead dist stat
First to stat the raw dist file:
```{bash,eval=FALSE}
perl -e 'while(<>){@a=split/\t/;$b=sprintf("%.4f",$a[2]);$HS{$b}++}foreach my $d (sort {$a<=>$b} keys %HS){print "$d\t$HS{$d}\n"}' RCA194FM_00/mash/bMin2.raw.dist 
> RCA194FM_00/mash/bMin2.raw.dist.stat
```


```{r load}
FM00.dir <- "../../Results/RCAs/RCA194FM_00/" 
#
beadAnno <- read.table(paste0(FM00.dir,"beadsAnno/bwa.uniq.anno.stat"),header=T)[,1:6]

#
dist.stat <- read.table(paste0(FM00.dir,"mash/bMin2.raw.dist.stat"),
                        col.names = c("dist","count"))
bMin2.raw.dist.stat <- read.table(
  paste0(FM00.dir,"/mash/bMin2.raw.dist.anno.stat"),sep="\t",header=T)

ITS.prf <- read.csv(paste0(FM00.dir,"ref/7fungi_mock.csv"),header=T)

ref.name <- data.frame(
  ID4=c("*","AACD","AAIL","ABDG","BCGH","JMSF","JOMC","JQFZ","MBDJ"),
  strain=c("*","Aspergillus_nidulans","Trichoderma_reesei","Trichoderma_atroviride","Trichoderma_koningii",
           "Penicillium_chrysogenum","Aspergillus_ustus","Penicillium_expansum","Trichoderma_longibrachiatum"),
  genus=c("*","Aspergillus","Trichoderma","Trichoderma","Trichoderma",
           "Penicillium","Aspergillus","Penicillium","Trichoderma")
)
ref.name$strain <- factor(ref.name$strain,
                          levels=c("*","Aspergillus_nidulans","Trichoderma_reesei","Trichoderma_atroviride",
                                   "Trichoderma_koningii","Penicillium_chrysogenum","Aspergillus_ustus",
                                   "Penicillium_expansum","Trichoderma_longibrachiatum"))
```

**beads belongings**
```{r}
colnames(beadAnno)[2] <- "mainContig"
beadAnno$mainTax <- substr(beadAnno$mainContig,1,4)

beadAnno.sum <- ddply(beadAnno,c("mainContig","mainTax"),summarise,count=length(Bead))
beadAnno.sum <- merge(beadAnno.sum,ref.name,by.x="mainTax",by.y="ID4")

ggplot(beadAnno.sum,aes(x=count,color=mainTax)) + geom_density() + scale_x_log10()
tmp.sum <- beadAnno.sum%>%filter(count>1000)
tmp.sum$mainContig <- droplevels(tmp.sum$mainContig)
ggplot(beadAnno.sum,
       aes(x=strain,y=count,fill=mainContig)) + geom_bar(stat="identity",position="stack") + 
  guides(fill=F) + coord_flip()

```

```{r}

ggplot(beadAnno[-1,],aes(x=reads,y=uniqPct)) + geom_density2d()
```


**genus level**
```{r}
beadAnno.Gsum <- ddply(beadAnno.sum,c("genus"),summarise,count=sum(count))

ITS.prf.df <- melt(ITS.prf,id.vars = c("OTU","genus","species","OTU_ID"),variable.name = "sample",value.name = "count")
ITS.rpf.Gsum <- ddply(ITS.prf.df,c("genus","sample"),summarise,count=sum(count))

comapre.df <- rbind(cbind(ITS.rpf.Gsum,method="ITS"),
                    cbind(beadAnno.Gsum,method="ITS",sample="fungi_mock_RCA"))

ggplot(comapre.df,aes(x=sample,y=count,fill=genus)) + geom_bar(stat="identity",position="fill") + coord_flip()
```

**species level**
```{r}
beadAnno.Ssum <- ddply(beadAnno.sum,c("genus","strain"),summarise,count=sum(count))
colnames(beadAnno.Ssum)[2] <- "species"

ITS.rpf.Ssum <- ddply(ITS.prf.df,c("genus","species","sample"),summarise,count=sum(count))

comapre.S.df <- rbind(cbind(ITS.rpf.Ssum,method="ITS"),
                    cbind(beadAnno.Ssum,method="ITS",sample="fungi_mock_RCA"))

ggplot(comapre.S.df,aes(x=sample,y=count,fill=species)) + geom_bar(stat="identity",position="fill") + 
  coord_flip() + facet_grid(.~genus) + guides(fill=F)
```

```{r}
ggplot(dist.stat,aes(x=dist,y=count)) + geom_line(alpha=.3) + 
  geom_point(size=.5) + scale_y_log10() + scale_x_continuous(breaks=seq(0,0.2,0.02))
```

```{r}
colnames(bMin2.raw.dist.stat)[1:2]<-c("contig1","contig2")
bMin2.raw.dist.stat$tax1 <- substr(bMin2.raw.dist.stat$contig1,1,4)
bMin2.raw.dist.stat$tax2 <- substr(bMin2.raw.dist.stat$contig2,1,4)
dist.stat <- bMin2.raw.dist.stat%>%filter(tax1!=""&tax2!="")

dist.stat.sum <- ddply(dist.stat,c("tax1","tax2","distance"),summarise,count=sum(count))
dist.stat.sum$group <-ifelse(dist.stat.sum$tax1==dist.stat.sum$tax2,"same","diff")
#dist.stat.sum2<- dist.stat.sum%>%filter(tax1!="*"&tax2!="*")
dist.stat.sum2 <- merge(dist.stat.sum,ref.name,by.x="tax2",by.y="ID4",sort=F)

ggplot(dist.stat.sum2,aes(x=distance,y=count,color=interaction(tax1,tax2),linetype=group)) +
  geom_line() + geom_vline(xintercept = 0.1,linetype=2)
ggplot(dist.stat.sum2,aes(x=distance,y=count,color=interaction(tax1,tax2),linetype=group)) +
  geom_line(size=1) + geom_vline(xintercept = 0.1,linetype=2) + facet_grid(tax1~strain,scale="free")
```

**ratio**
```{r}
dist.stat.sum3 <- ddply(dist.stat.sum2,c("tax2","distance"),transform,
                        ratio=count/count[which(group=="same")])
ggplot(dist.stat.sum3,aes(x=distance,y=ratio,color=interaction(tax1,tax2),linetype=group)) +
  geom_line(size=1) + geom_vline(xintercept = c(0.02,0.04,0.1),linetype=2) + facet_grid(tax1~strain,scale="free") +
  scale_y_log10()
```



**sum them together**
```{r}
dist.stat.sum2 <- ddply(dist.stat.sum,c("distance","group"),summarise,count=sum(count))
ggplot(dist.stat.sum2,aes(x=distance,y=count,linetype=group),color="grey50",alpha=.3) +
  geom_line() + geom_point(size=.5) + geom_vline(xintercept = 0.1,linetype=2)
```


**31kmer distance**
```{r}
dist.31mker.stat <- read.table(
  paste0(FM00.dir,"/00d06_31mer/mash/bMin2.raw.anno.stat"),sep="\t",header=T)
dist.31mker.stat <- dist.31mker.stat%>%filter(tax1!=""&tax2!="")
dist.31mker.stat$strain1 <- substr(as.character(dist.31mker.stat$tax1),1,4)
dist.31mker.stat$strain2 <- substr(as.character(dist.31mker.stat$tax2),1,4)
dist.31mker.stat$group <- ifelse(as.character(dist.31mker.stat$tax1)==as.character(dist.31mker.stat$tax2),"same","diff")

dist.31mker.stat$comSP <- ifelse(dist.31mker.stat$strain1==dist.31mker.stat$strain2,"same","diff")

dist.31mker.sumSP <- ddply(dist.31mker.stat,c("distance","comSP","strain1","strain2"),summarise,sumcount=sum(count))
ggplot(dist.31mker.sumSP,aes(x=distance,y=sumcount,color=comSP)) + geom_point(size=1) + facet_grid(strain1~strain2)


```

# bead Annotation
```{bash prep,eval=FALSE}
SAM0=RCA194FM_00
bwa mem -t 48 -o $SAM0/beadsAnno/bwa.sam ../../Source/REF/fungal7mix/MIX7.bwa $SAM0/clean/fastp.sort.{1,2}.fq

perl -e 'while(<>){@a=split; $xa=0;
if($a[-1]=~/^XA/){@c=split(/;/,$a[-1]);$xa=0;while(@c>0){$i=shift @c; $xa+=($i=~/$a[2]/)?0:1}}; 
next if $xa >0 ||$a[1] > 1024;
@b=split("/",$a[0]);
if($b[1]=~/0000/){$b[1]="0000_0000_0000"};$HS{$b[1]}{$a[2]}++};
@ref=sort keys %{$HS{"0000_0000_0000"}};print "Bead";
foreach my $tax (@ref){print "\t$tax"};print "\n";
foreach $b (sort keys %HS){print "$b";foreach my $tax (@ref){
$HS{$b}{$tax}||=0;
print "\t$HS{$b}{$tax}"};print "\n"}' < $SAM0/beadsAnno/bwa.sam > $SAM0/beadsAnno/bwa.uniq.anno.count

perl -e '$once=1;while(<>){@a=split;if($a[0]=~/0000/){$b+=($a[2]-$a[1]+1)/4;next}elsif($once){print "0000_0000_0000\t$b\n";$once--};$b=($a[2]-$a[1]+1)/4;print "$a[0]\t$b\n"}' < $SAM0/clean/fastp.sort.1.fq.idx > $SAM0/beadsAnno/beads.num.count

perl -e 'open I,"<'$SAM0'/beadsAnno/beads.num.count"; while(<I>){@a=split;$HS{$a[0]}=$a[1]};
$head=<>;@names=split(/\t/,$head); shift @names;
printf("%s\t%s\t%s\t%s\t%s\t%s\t", "Bead","mainTax","mainPct","uniqPct","uniq","reads");print "@names";
while(<>){chomp; @a=split /\t/; $bb=shift @a;$sum=0; for($i=0;$i<@a;$i++){$sum+=$a[$i]}; @b=sort {$a<=>$b} @a; 
if($b[-1] == $b[-2]){$maxTax="NA"}else{for($i=0;$i<@a;$i++){
$maxTax=$names[$i] if $a[$i]==$b[-1]}; printf("%s\t%s\t%.4f\t%.4f\t%d\t%d", $bb,$maxTax,$b[-1]/$sum,$sum/($HS{$bb}*2),$sum,$HS{$bb}*2); print "\t@a\n"}}' $SAM0/beadsAnno/bwa.uniq.anno.count|sed 's/ /\t/g' > $SAM0/beadsAnno/bwa.uniq.anno.stat

#stat coverage
perl -e '$prv="";sub ccov{$k=shift;if($k>90){$k=91};return($k)}; while(<>){
  if($_=~/^\@SQ\tSN:(\S+)\tLN:(\d+)/){$REF{$1}=$2; next};
  @a=split; next if $a[1] > 1024 || $a[6] ne "=" || $a[8]<0;
  @b=split("/",$a[0]); 
  $c ++ if $b[1] ne $prv;
  if($b[1]=~/0000/){
    for($i=0;$i<$a[8];$i++){ $H0{$a[2]}{$a[3]+$i} ++;}
    $prv=$b[1];
  }else{
    if($b[1] ne $prv){
      #print STDERR "print $prv(!=$b[1] at $.) ; \$c=$c\n";
      foreach $t (sort keys %HS){
        print "$prv\t$t\t";for($i=1;$i<=$REF{$t};$i++){
          $HS{$t}{$i}||=0; print chr(33+&ccov($HS{$t}{$i}));
        }; print "\n";
      }; undef %HS;
    }; for($i=0;$i<$a[8];$i++){ $HS{$a[2]}{$a[3]+$i} ++}; $prv=$b[1];};
}; foreach $t (sort keys %HS){print "$prv\t$t\t";for($i=1;$i<=$REF{$t};$i++){
  $HS{$t}{$i}||=0; print chr(33+&ccov($HS{$t}{$i}));$HS{$t}{$i}=0};print "\n";};
foreach $t (sort keys %H0){print "0000_0000_0000\t$t\t";for($i=1;$i<=$REF{$t};$i++){
    $H0{$t}{$i}||=0; print chr(33+&ccov($H0{$t}{$i}))};print "\n";}
' < $SAM0/beadsAnno/bwa.sam > $SAM0/beadsAnno/bwa.pair.cov.stat

## unique
perl -e '$prv="";sub ccov{$k=shift;if($k>90){$k=91};return($k)}; while(<>){
  if($_=~/^\@SQ\tSN:(\S+)\tLN:(\d+)/){ $REF{$1}=$2; next};
  @a=split; next if $a[4]<60 || $a[1] > 1024 || $a[6] ne "=" || $a[8]<0;
  @b=split("/",$a[0]); 
  $c ++ if $b[1] ne $prv;
  if($b[1]=~/0000/){
    for($i=0;$i<$a[8];$i++){ $H0{$a[2]}{$a[3]+$i} ++;}
    $prv=$b[1];
  }else{
    if($b[1] ne $prv){
      #print STDERR "print $prv(!=$b[1] at $.) ; \$c=$c\n";
      foreach $t (sort keys %HS){
        print "$prv\t$t\t";for($i=1;$i<=$REF{$t};$i++){
          $HS{$t}{$i}||=0; print chr(33+&ccov($HS{$t}{$i}));
        }; print "\n";
      }; undef %HS;
    }; for($i=0;$i<$a[8];$i++){ $HS{$a[2]}{$a[3]+$i} ++}; $prv=$b[1];};
}; foreach $t (sort keys %HS){print "$prv\t$t\t";for($i=1;$i<=$REF{$t};$i++){
  $HS{$t}{$i}||=0; print chr(33+&ccov($HS{$t}{$i}));$HS{$t}{$i}=0};print "\n";};
foreach $t (sort keys %H0){print "0000_0000_0000\t$t\t";for($i=1;$i<=$REF{$t};$i++){
    $H0{$t}{$i}||=0; print chr(33+&ccov($H0{$t}{$i}))};print "\n";}
' < $SAM0/beadsAnno/bwa.sam > $SAM0/beadsAnno/bwa.uniq.cov.stat

###summary coverage
perl -e 'while(<>){ chomp; @a=split;
  for($i=0;$i<length($a[2]);$i++){ $HS{$a[1]}{$i}+=ord(substr($a[2],$i,1))-33;}
};foreach $t (sort keys %HS){foreach $i (sort {$a<=>$b} keys %{$HS{$t}}){
  print "$t\t$i\t$HS{$t}{$i}\n";
}}' < $SAM0/beadsAnno/bwa.uniq.cov.stat > $SAM0/beadsAnno/bwa.uniq.cov.sum1
perl -e 'while(<>){ chomp; @a=split;
  for($i=0;$i<length($a[2]);$i++){ $HS{$a[1]}{$i}+=ord(substr($a[2],$i,1))-33;}
};foreach $t (sort keys %HS){foreach $i (sort {$a<=>$b} keys %{$HS{$t}}){
  print "$t\t$i\t$HS{$t}{$i}\n";
}}' < $SAM0/beadsAnno/bwa.pair.cov.stat > $SAM0/beadsAnno/bwa.pair.cov.sum1


perl ../07.test_1mAsm/itsAnno.pl $SAM0/beadsAnno/bwa.sam $SAM0/beadsAnno/its.anno

perl -e 'open I,"<'$SAM0'/beadsAnno/bwa.uniq.anno.stat"; <I>;<I>;
while(<I>){@a=split; next if $a[4]==2;
  $HS{$a[0]}{tax}=$a[1];$HS{$a[0]}{pct}=$a[2];
};while(<>){@a=split; next if $a[0]==$a[1]; @b=sort ($HS{$a[0]}{tax},$HS{$a[1]}{tax});
  $min=($HS{$a[0]}{pct}<$HS{$a[1]}{pct})?$HS{$a[0]}{pct}:$HS{$a[1]}{pct};
  $HS2{$b[0]}{$b[1]}{sprintf("%.2f",$min)}{sprintf("%.2f",$a[2])} ++;
};print "tax1\ttax2\tmainPct\tdistance\tcount\n";
foreach $t1 (sort keys %HS2){foreach $t2 (sort keys %{$HS2{$t1}}){
    foreach $pct (sort keys %{$HS2{$t1}{$t2}}){
      foreach $dst (sort keys %{$HS2{$t1}{$t2}{$pct}}){
        printf("%s\t%s\t%f\t%f\t%d\n",$t1,$t2,$pct,$dst,$HS2{$t1}{$t2}{$pct}{$dst})
}}}}' < $SAM0/mash/bMin2.raw.dist > $SAM0/mash/bMin2.raw.dist.anno.stat

```

```{r load bead anno}
SAM0="RCA194FM_00"

bwa.uniq.anno.stat <- read.table(header=T,sep="\t",
  file=paste0("../../Results/RCAs/",SAM0,"/beadsAnno/bwa.uniq.anno.stat"))
bwa.uniq.cov.sum1 <- read.table(col.names=c("taxonomy","position","coverage"),
  file=paste0("../../Results/RCAs/",SAM0,"/beadsAnno/bwa.uniq.cov.sum1"))
bwa.pair.cov.sum1 <- read.table(col.names=c("taxonomy","position","coverage"),
  file=paste0("../../Results/RCAs/",SAM0,"/beadsAnno/bwa.pair.cov.sum1"))
```

```{r visual}
sum.uniq.anno <- ddply(
  bwa.uniq.anno.stat,c("reads"),summarise,uniq=sum(uniq),sumReads=sum(reads)/2,
  Au=sum(X158)/sum(uniq),Pe=sum(X160)/sum(uniq),An=sum(X161)/sum(uniq),
  Pc=sum(X162)/sum(uniq),Tl=sum(X163)/sum(uniq),Tc=sum(X164)/sum(uniq),
  As=sum(X452)/sum(uniq))

sum.uniq.anno$reads[nrow(sum.uniq.anno)] <- 0.2
sum.uniq.anno$reads <- sum.uniq.anno$reads/2
sum.uniq.anno$beads <- sum.uniq.anno$sumReads/sum.uniq.anno$reads
sum.uniq.anno2 <- melt(sum.uniq.anno,id.vars = c("uniq","reads","sumReads","beads"),
                       variable.name = "taxonomy", value.name = "ratio")
sum.uniq.anno2$sRp <- sum.uniq.anno2$sumReads/sum.uniq.anno2$sumReads[nrow(sum.uniq.anno)]
sum.uniq.anno2$sBp <- sum.uniq.anno2$beads/sum.uniq.anno2$beads[1]
ggplot(sum.uniq.anno2,aes(x=reads,y=ratio,color=taxonomy),alpha=.1) +
  geom_point(size=1,alpha=.5) + geom_line(linetype=1,alpha=.3) +
  geom_line(aes(y=sBp),color="grey50",linetype=2) +
  xlab("reads per bead") + annotation_logticks(sides = "b") +
  scale_x_log10(limits=c(0.1,1000)) +
  scale_y_continuous(breaks=seq(0,1,.2),limits=c(0,1))

```

```{r}
bwa.comb.cov.sum1 <- rbind(
  cbind(type="uniq",bwa.uniq.cov.sum1),
  cbind(type="pair",bwa.pair.cov.sum1)
)

ggplot(bwa.comb.cov.sum1,aes(x=position,y=coverage)) + geom_line(aes(color=type)) +
  facet_wrap(~taxonomy,ncol=3,scale="free")
```

```{r}
bwa.uniq.curate <- filter(bwa.uniq.anno.stat[-1,],reads>2 )
ggplot(bwa.uniq.curate,aes(x=log10(reads/2),y=mainPct*100)) +
  geom_point(alpha=.1) + annotation_logticks(sides = "b") +
  geom_vline(xintercept = log10(c(50,100)),linetype=2) +
  stat_density_2d(h=c(1,50)) + facet_wrap(~mainTax,ncol=3)
```

#Isolated assembly stat
This time I removed SSU TW primers
```{bash,eval=FALSE}
SAM0="RCA194FM_00"
tag="00d10"
mkdir -p $SAM0/$tag/mash
rm $SAM0/mash && ln -sf $SAM0/$tag/mash $SAM0/mash

#DRY RUN!
metabbq smk -j -np $SAM0/mash/bMin2.msh #quick glance of the kmers number in each bead
metabbq smk -j -np $SAM0/summary.BI.megahit.contig.fasta
#post
mv $SAM0/summary.BI.megahit.* $SAM0/$tag/
blastn -num_threads 32 -db REF/fungal7mix/MIX7.blast -query $SAM0/$tag/summary.BI.megahit.contig.fasta \
-outfmt 6 > $SAM0/$tag/summary.BI.megahit.contig.m6
sed 's/_/\t/g' $SAM0/$tag/summary.BI.megahit.contig.m6 >$SAM0/$tag/summary.BI.megahit.contig.anno
#pick info from msh
mash info $SAM0/mash/bMin2.msh|perl -e 'while(<>){if($_=~/(\d+)\s+(\d+)\s+(\S+)\s+\[(\d+) seqs\]/){
print "$3\t$4\t$2\n"}}' > $SAM0/mash/bMin2.msh.info

#quast.py
quast.py $SAM0/$tag/summary.BI.megahit.contig.fasta -r REF/fungal7mix/MIX7.fa -o $SAM0/$tag/quast
#ITSx
mkdir -p $SAM0/$tag/summary.BI.megahit.contig.ITSx
ITSx -t F --cpu 48 -i $SAM0/$tag/*fasta -o $SAM0/$tag/summary.BI.megahit.contig.ITSx
```

#ASM
#bwa asm to ref


```{r}
SAM0="RCA194FM_00"
tag="00d10"

msh.info <- read.table(paste(sep="/",RESDIR,SAM0,tag,"mash/bMin2.msh.info"),
                             col.names = c("BB","rpb","kmerN"))
megahit.contig <- read.table(paste(sep="/",RESDIR,SAM0,tag,"summary.BI.megahit.contig.tsv"),
                             col.names = c("BI","ID","flag","multi","len"))

megahit.anno <- read.table(paste0(RESDIR,"/",SAM0,"/",tag,"/summary.BI.megahit.contig.anno"),
  col.names = c("BI","kmer","num","cov","sLen","sid","pident", "length", "mismatch", "gapopen",
                "qstart", "qend", "sstart", "send", "evalue", "bitscore"))
megahit.anno$ID <- paste(megahit.anno$kmer,megahit.anno$num,sep="_")

```

**landscape**
```{r}
ggplot(msh.info,aes(x=rpb,y=kmerN)) + geom_point()
```

About megahit `flag`:  
> flag is a tag to represent the connectivity of a contig in the assembly graph. 
flag=1 means the contig is standalone, 
flag=2 a looped path and 
flag=0 for other contigs.
>
> multi is roughly the average kmer coverage. But the figure is not precise and if you want to quantify the coverage of a contig, I would suggest you align the reads back to the contigs by short read aligners.
>https://github.com/voutcn/megahit/issues/54

```{r}
ggplot(megahit.contig,aes(x=len,y=multi,color=factor(flag))) + geom_point(alpha=.1)
```


```{r}
cut.megahit.contig <- megahit.contig%>%filter(len>1000)
cut.megahit.contig$BI <- reorder(cut.megahit.contig$BI,cut.megahit.contig$len,mean)
cut.megahit.contig <- cut.megahit.contig[order(cut.megahit.contig$len),]
cut.BI.names <- as.character(unique(cut.megahit.contig$BI))

megahit.contig.anno <- merge(cut.megahit.contig,megahit.anno,by=c("BI","ID"),all.x=T)
megahit.contig.anno$strainID <- substr(megahit.contig.anno$sid,1,4)
ggplot(megahit.contig.anno,aes(x=BI)) +
  #geom_boxplot(aes(y=len),alpha=.5) + 
  coord_flip() + 
  labs(x="Bead cluster ID",y="scaffold length",size="coverage") +
  geom_point(aes(y=len,size=multi,fill=strainID),shape=21,alpha=.5)

ggplot(megahit.contig.anno%>%filter(len <1500),aes(x=BI)) +
  #geom_boxplot(aes(y=len),alpha=.5) + 
  coord_flip() + geom_path(aes(group=BI,y=len)) +
  labs(x="Bead cluster ID",y="scaffold length",size="coverage") +
  geom_point(aes(y=len,size=multi,fill=strainID),shape=21,alpha=.5)

```
```{r}
refCount <-ddply(megahit.contig.anno%>%filter(pident>99&length>999),c("strainID","sid"),summarise,count=length(sid),len=mean(length))
refCount
```

#blast select scaf to nt
```{bash}
blastn -num_threads 32 -db $MDB/NCBI/blast_nt/nt -query RCA194FM_00/00d10/summary.BI.megahit.contig.fasta \
-outfmt '6 std staxid ssciname' -out RCA194FM_00/00d10/summary.BI.megahit.contig.blast

blastn -num_threads 32 -db $MDB/NCBI/blast_nt/nt -query RCA194FM_00/summary.BI.megahit.contig.fasta -outfmt '6 std staxid ssciname stitle' -out RCA194FM_00/summary.BI.megahit.contig.b6

#make a primer lsit first
#command refer to http://bioweb.cbm.uam.es/courses/MasterVirol2013/alignment/BLAST-NCBI-programs.htm
blastn -num_threads 8 -query primers.fa -db RCA194FM_00/blast/summary.BI.megahit.contig.fasta \
-out RCA194FM_00/blast/summary.BI.megahit.contig.b6 -outfmt 6 -word_size 7 -evalue 10
```

# Beads isolate assembly

### FM: 7 fungal mixture
```{bash}
SAM0="RCA194FM_00"
tag="BI02d03"
metabbq smk --force -j -np RCA194FM_00/summary.BI.megahit.contig.fasta
bwa mem -t 48 ../../Source/REF/fungal7mix/MIX7.bwa $SAM0/$tag/summary.BI.megahit.contig.fasta 
-o $SAM0/$tag/summary.BI.megahit.contig.sam

grep -v "^@" $SAM0/$tag/summary.BI.megahit.contig.sam|awk '{for(i=10;i<20;i++){if($i~/^SA:/){a=i}};
print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6"\t"$7"\t"$8"\t"$9"\t"$a;}' |\
sed 's/_/\t/;s/\(k[0-9]*\_[0-9]*\)\_\([.0-9]*\)\_\([0-9]*\)/\1\t\2\t\3/' > \
$SAM0/$tag/summary.BI.megahit.contig.sam.sum

```

```{r}
rpb.curve <- data.frame(rpb=seq(1,300))
rpb.curve$k21n <- (rpb.curve$rpb*100-20)*2*2

ggplot(rpb.curve,aes(x=rpb,y=k21n)) + geom_point() + geom_line() + 
  geom_hline(yintercept = 5600,linetype=2) + scale_y_log10() + scale_x_log10() + annotation_logticks()
```



**load**
```{r}
SAM0="RCA194FM_00"
tag="BI02d03"
BI.megahit.contig <- read.table(paste0(RESDIR,SAM0,"/",tag,"/summary.BI.megahit.contig.tsv"),
                             col.names = c("BI","scaf","flag","multi","len"))

megahit.anno <- read.table(paste0(RESDIR,"/",SAM0,"/",tag,"/summary.BI.megahit.contig.sam.sum"),fill=NA,
  col.names = c("BI","scaf","cov","sLen","FLAG","RNAME", "POS", "MAPQ", "CIGAR","RNEXT", "PNEXT", "TLEN","SA"))

BI.stat <- read.table("../../Results/RCA194FM_00/BI02d03/Assemble_BI/ID.lst",
                      col.names = c("ID","BB","reads"))
BI.kmer.stat <- read.table("../../Results/RCAs/RCA194FM_00/00d10/mash/bMin2.msh.more.stat",col.names=c("BI","BB","seqs","kmerN","rpb"))
```

```{r}
BB.stat <- read.table("../../Results/RCAs/RCA194FM_00/clean/BB.stat",
                      col.names = c("count","reads","cumsum"))
ggplot(BB.stat,aes(y=cumsum,x=reads)) + geom_point() + 
  scale_y_log10() + scale_x_reverse() + labs(x="Reads per bead") + 
  annotation_logticks(side="l")
```

**assembly overview**
```{r}
BI.kmer.stat$group <- ifelse(BI.kmer.stat$BI=="BI000000","short","BI")
ggplot(BI.kmer.stat,aes(x=seqs,y=kmerN,color=group)) + geom_point(alpha=.3) 
```

```{r}
BI.kmer.stat <- BI.kmer.stat%>%filter(BI!="BI000000")

BI.megahit.ctg <- merge(BI.megahit.contig,BI.kmer.stat,by="BI",all.x=T)
ggplot(BI.megahit.ctg%>%filter(len>1000),aes(x=seqs,y=kmerN,size=multi)) + geom_point(alpha=.3) 
```

```{r}
BI.stat$BI = sprintf("BI%06d",BI.stat$ID)
cut.megahit.contig <- merge(BI.megahit.ctg%>%filter(len>500),BI.stat,by="BI")
cut.megahit.contig$BI <- reorder(cut.megahit.contig$BI,cut.megahit.contig$len,mean)
cut.megahit.contig <- cut.megahit.contig[order(cut.megahit.contig$len),]
cut.BC.names <- as.character(unique(cut.megahit.contig$BI))
cut.megahit.anno <- merge(cut.megahit.contig,megahit.anno%>%filter(FLAG<2048),by=c("BI","scaf"),all.x=T)
cut.megahit.anno$ID4 <- substr(cut.megahit.anno$RNAME,1,4)
cut.megahit.anno <- merge(ref.name,cut.megahit.anno,by="ID4")

ggplot(cut.megahit.anno,aes(y=reads,x=sLen)) + geom_path(aes(group=BI),alpha=.3,linetype=1) +
  geom_point(aes(color=strain,size=multi),alpha=.7) + 
  labs(x="scaffold length",y="Reads per bead(rpb)",size="coverage") +
  scale_color_brewer(palette = "Spectral",na.value="grey50")


ggplot(cut.megahit.anno,aes(x=seqs,y=kmerN,size=multi,color=strain)) + geom_point(alpha=.3)
```
### ALS: real soil sample
Real sample could be too complex using cluster method, let's only pick large beads
for isolated bead assembly

```{bash}
SAM="RCA194ALS"
metabbq smk --config p_rpb_min=199 -j -np $SAM/summary.BI.megahit.contig.fasta
```

```{r}
ALS.BB.stat <- read.table("../../Results/RCAs/RCA194ALS/clean/BB.stat",
                      col.names = c("count","reads","cumsum"))
ggplot(ALS.BB.stat,aes(y=cumsum,x=reads)) + geom_point() + geom_vline(xintercept = 200) +
  scale_y_log10() + scale_x_reverse() + labs(x="Reads per bead") + 
  annotation_logticks(side="l")
ALS.BB.stat%>%filter(reads==200)
```

**megahit asm stat**
```{r}
ALS.ID.lst <- read.table("../../Results/RCAs/RCA194ALS/Assemble_BI/ID.lst",
                         col.names = c("ID","BB","reads"))
ALS.asm.stat <- read.table("../../Results/RCAs/RCA194ALS/tmp.megahit.stat",
                           col.names = c("BI","scaf","flag","multi","len"))
ALS.ID.lst$BI <- sprintf("BI%08d",ALS.ID.lst$ID,by="BI")
ALS.mID.stat <- merge(ALS.ID.lst[1:4000,],ALS.asm.stat,by="BI",all.x=T)

length(unique((ALS.asm.stat%>%filter(len>1000))$BI))
length(unique(ALS.asm.stat$BI))
ggplot(ALS.mID.stat,aes(x=reads)) + geom_histogram() + labs(x="reads per bead")
ggplot(ALS.mID.stat,aes(x=len)) + geom_histogram() + labs(x="scaffold length")
ggplot(ALS.mID.stat,aes(x=len,y=multi)) + geom_density_2d(alpha=.3) + geom_point(alpha=.1) + 
  scale_x_continuous(limits=c(0,3000)) 
```


```{r}
ggplot(ALS.mID.stat,aes(x=reads,y=len,color=multi)) +geom_density_2d(alpha=.3) + 
  geom_point(alpha=.3) + scale_colour_distiller(type="seq",palette="Spectral") +
  scale_y_continuous(limits=c(0,3000)) + 
  labs(x="reads per bead",y="scaffold length",color="Coverage")
```

```{r}
ALS.mID.s2 <- ddply(ALS.mID.stat,c("BI","reads"),summarise,
                    totalLen=sum(len),totalCov=sum(multi*len)/sum(len))
ggplot(ALS.mID.s2,aes(x=reads,y=totalLen,color=totalCov)) +geom_density_2d(alpha=.3) + 
  geom_point(alpha=.3) + scale_colour_distiller(type="seq",palette="Spectral") +
  scale_y_continuous(limits=c(0,3000)) +
   labs(x="reads per bead",y="scaffold length",color="Coverage")
```

**spades asm stat**
```{r}
ALS.spades.stat <- read.table("../../Results/RCAs/RCA194ALS/tmp.spades.stat",
                           col.names = c("BI","scaf","length","cov"))
ALS.sID.stat <- merge(ALS.ID.lst[1:4000,],ALS.spades.stat,by="BI",all.x=T)

length(unique((ALS.sID.stat%>%filter(length>1000))$BI))
length(unique(ALS.spades.stat$BI))
ggplot(ALS.sID.stat,aes(x=reads)) + geom_histogram() + labs(x="reads per bead")
ggplot(ALS.sID.stat,aes(x=length)) + geom_histogram() + labs(x="scaffold length")
ggplot(ALS.sID.stat,aes(x=length,y=cov)) + geom_density_2d(alpha=.3) + geom_point(alpha=.1) + 
  scale_x_continuous(limits=c(0,3000)) 
```
```{r}

```

```{r}
ggplot(ALS.sID.stat%>%filter(!is.na(scaf)&length>1000),aes(x=reads,y=length,color=log2(cov))) +
  geom_point(alpha=.3) + geom_density_2d(alpha=.3) + 
  scale_colour_distiller(type="seq",palette="Spectral") +
  #scale_y_continuous(limits=c(0,3000)) + 
  labs(x="reads per bead",y="scaffold length",color="Coverage")
```

